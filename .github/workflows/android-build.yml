name: Build Android APK

# Dynamic run name based on app name from mutation response
# Shows app name instead of "android_build" in GitHub Actions UI
run-name: ${{ github.event.client_payload.app_name || 'Android Build' }}

permissions:
  contents: write
 
on:
  workflow_dispatch:
    inputs:
      app_id:
        description: "App ID"
        required: true
  repository_dispatch:
    types: [android_build]
 
jobs:
  build:
    runs-on: ubuntu-latest
 
    env:
      APP_ID: ${{ github.event.client_payload.app_id || github.event.inputs.app_id }}
      APP_NAME: ${{ github.event.client_payload.app_name || '' }}
      APP_LOGO: ${{ github.event.client_payload.app_logo || '' }}
 
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3
 
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
 
      - name: Install dependencies
        run: npm install
 
      - name: Set App Name and Logo from Mutation
        id: set_app_info
        run: |
          echo "Building for APP_ID=${APP_ID}"
          # Use app_name from mutation response (triggerAndroidBuild)
          if [ -n "${{ env.APP_NAME }}" ]; then
            echo "âœ… App Name from mutation: ${{ env.APP_NAME }}"
            echo "APP_NAME=${{ env.APP_NAME }}" >> $GITHUB_ENV
            # Update workflow run name to show app name (if supported by GitHub API)
            echo "::notice title=App Name::Building for app: ${{ env.APP_NAME }}"
          else
            echo "âš ï¸ No app name from mutation, will fetch or use default"
          fi
          if [ -n "${{ env.APP_LOGO }}" ]; then
            echo "âœ… App Logo from mutation: ${{ env.APP_LOGO }}"
            echo "APP_LOGO=${{ env.APP_LOGO }}" >> $GITHUB_ENV
          fi

      - name: Fetch App Name and Icon (Fallback if not provided)
        env:
          APP_ID: ${{ env.APP_ID }}
          GRAPHQL_ENDPOINT: ${{ secrets.GRAPHQL_ENDPOINT || 'https://mobidrag.ampleteck.com/graphql' }}
          GRAPHQL_TOKEN: ${{ secrets.GRAPHQL_TOKEN }}
        run: |
          # Only fetch if app name was not provided from mutation
          if [ -z "${{ env.APP_NAME }}" ]; then
            echo "ðŸ“¡ Fetching app info from GraphQL as fallback..."
            node scripts/fetch-app-info.js || echo "âš ï¸ Failed to fetch app info"
            if [ -f app-info.json ]; then
              FALLBACK_NAME=$(node -p "require('./app-info.json').appName || ''")
              FALLBACK_ICON=$(node -p "require('./app-info.json').appIcon || ''")
              if [ -n "${FALLBACK_NAME}" ] && [ "${FALLBACK_NAME}" != "App-${APP_ID}" ]; then
                echo "APP_NAME=${FALLBACK_NAME}" >> $GITHUB_ENV
                echo "âœ… Using fetched app name: ${FALLBACK_NAME}"
              else
                echo "APP_NAME=App-${APP_ID}" >> $GITHUB_ENV
                echo "âš ï¸ Using default app name: App-${APP_ID}"
              fi
              if [ -n "${FALLBACK_ICON}" ] && [ -z "${{ env.APP_LOGO }}" ]; then
                echo "APP_LOGO=${FALLBACK_ICON}" >> $GITHUB_ENV
                echo "âœ… Using fetched app logo"
              fi
            else
              echo "APP_NAME=App-${APP_ID}" >> $GITHUB_ENV
              echo "âš ï¸ Using default app name: App-${APP_ID}"
            fi
          else
            echo "âœ… Using app name from mutation: ${{ env.APP_NAME }}"
          fi

      - name: Generate Package Name
        id: package_name
        env:
          APP_ID: ${{ env.APP_ID }}
        run: |
          CUSTOM_PACKAGE="${{ github.event.client_payload.package_name }}"
          if [ -n "${CUSTOM_PACKAGE}" ]; then
            PACKAGE_NAME="${CUSTOM_PACKAGE}"
          else
            # Generate with app prefix: com.mobidrag.builder.app{APP_ID}
            PACKAGE_NAME="com.mobidrag.builder.app${APP_ID}"
          fi
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
          echo "ðŸ“¦ Generated package name: ${PACKAGE_NAME}"

      - name: Fix Package Name (Auto-fix numeric segments)
        env:
          PACKAGE_NAME: ${{ env.PACKAGE_NAME }}
        run: |
          if [ -n "${PACKAGE_NAME}" ]; then
            echo "ðŸ”§ Checking and fixing package name..."
            # Capture only the last line (package name) from script output
            FIXED_PACKAGE=$(node scripts/fix-package-name.js "${PACKAGE_NAME}" 2>&1 | tail -n 1)
            if [ "${FIXED_PACKAGE}" != "${PACKAGE_NAME}" ]; then
              echo "âœ… Auto-fixed package name:"
              echo "   Original: ${PACKAGE_NAME}"
              echo "   Fixed:    ${FIXED_PACKAGE}"
              echo "PACKAGE_NAME=${FIXED_PACKAGE}" >> $GITHUB_ENV
            else
              echo "âœ… Package name is already valid: ${PACKAGE_NAME}"
            fi
          fi

      - name: Validate Package Name
        env:
          PACKAGE_NAME: ${{ env.PACKAGE_NAME }}
        run: |
          if [ -n "${PACKAGE_NAME}" ]; then
            echo "ðŸ” Validating package name..."
            node scripts/validate-package-name.js "${PACKAGE_NAME}" || exit 1
            echo "âœ… Package name is valid: ${PACKAGE_NAME}"
          fi

      - name: Update Package Name and App Name
        env:
          APP_ID: ${{ env.APP_ID }}
          APP_NAME: ${{ env.APP_NAME }}
          PACKAGE_NAME: ${{ env.PACKAGE_NAME }}
        run: |
          echo "ðŸ“¦ Updating package name and app name..."
          if [ -n "${APP_ID}" ]; then
            # Update Android package name and app name
            node scripts/update-android-package.js
            echo "âœ… Package name and app name updated"
            echo "ðŸ“± Package: ${PACKAGE_NAME}"
            echo "ðŸ“± App Name: ${APP_NAME}"
            
            # Verify files were moved correctly
            OLD_PATH="android/app/src/main/java/com/mobidrag"
            NEW_PATH="android/app/src/main/java/$(echo ${PACKAGE_NAME} | tr '.' '/')"
            if [ -d "${OLD_PATH}" ]; then
              echo "âš ï¸ WARNING: Old package directory still exists: ${OLD_PATH}"
              echo "ðŸ“‹ Contents:"
              ls -la "${OLD_PATH}" || echo "Could not list contents"
            fi
            if [ -d "${NEW_PATH}" ]; then
              echo "âœ… New package directory exists: ${NEW_PATH}"
              echo "ðŸ“‹ Contents:"
              ls -la "${NEW_PATH}" || echo "Could not list contents"
            else
              echo "âš ï¸ WARNING: New package directory not found: ${NEW_PATH}"
            fi
          else
            echo "âš ï¸ APP_ID not set, skipping package name update"
          fi

      - name: Update app.json
        env:
          APP_NAME: ${{ env.APP_NAME }}
          APP_LOGO: ${{ env.APP_LOGO }}
        run: |
          node -e "
            const fs = require('fs');
            const appJson = JSON.parse(fs.readFileSync('app.json', 'utf8'));
            if (process.env.APP_NAME) {
              appJson.name = process.env.APP_NAME;
              appJson.displayName = process.env.APP_NAME;
            }
            if (process.env.APP_LOGO) {
              appJson.logo = process.env.APP_LOGO;
            }
            fs.writeFileSync('app.json', JSON.stringify(appJson, null, 2));
          "
          if [ -n "${APP_NAME}" ]; then
            echo "âœ… Updated app.json with app name: ${APP_NAME}"
          fi
          if [ -n "${APP_LOGO}" ]; then
            echo "âœ… Updated app.json with app logo: ${APP_LOGO}"
          fi

      - name: Install ImageMagick for icon resizing
        if: env.APP_LOGO != ''
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick || echo "âš ï¸ ImageMagick installation failed, will use fallback"

      - name: Download and Update App Icon
        env:
          APP_LOGO: ${{ env.APP_LOGO }}
        run: |
          if [ -n "${APP_LOGO}" ]; then
            echo "ðŸ“¥ Downloading app icon from: ${APP_LOGO}"
            node scripts/update-app-icon.js
            echo "âœ… App icon update completed"
          else
            echo "âš ï¸ No app logo provided, skipping icon update"
          fi

      - name: Copy app.json to Android assets
        run: |
          # Ensure app.json exists and is up-to-date (create default if not)
          if [ ! -f app.json ]; then
            echo '{"name":"MobiDrag","displayName":"MobiDrag"}' > app.json
            echo "âš ï¸ Created default app.json"
          fi
          
          # Verify app.json has the correct app name
          CURRENT_NAME=$(node -p "require('./app.json').name || 'MobiDrag'")
          EXPECTED_NAME="${{ env.APP_NAME }}"
          if [ -n "${EXPECTED_NAME}" ] && [ "${CURRENT_NAME}" != "${EXPECTED_NAME}" ]; then
            echo "âš ï¸ app.json name (${CURRENT_NAME}) doesn't match expected (${EXPECTED_NAME}), updating..."
            node -e "
              const fs = require('fs');
              const appJson = JSON.parse(fs.readFileSync('app.json', 'utf8'));
              appJson.name = '${EXPECTED_NAME}';
              appJson.displayName = '${EXPECTED_NAME}';
              fs.writeFileSync('app.json', JSON.stringify(appJson, null, 2));
            "
            echo "âœ… Updated app.json with app name: ${EXPECTED_NAME}"
          fi
          
          mkdir -p android/app/src/main/assets
          cp app.json android/app/src/main/assets/app.json
          echo "âœ… Copied app.json to Android assets"
          echo "ðŸ“„ App name in app.json: $(node -p "require('./app.json').name")"
          
          # Verify the file was copied correctly
          if [ -f android/app/src/main/assets/app.json ]; then
            echo "âœ… Verified: app.json exists in assets folder"
            echo "ðŸ“„ Content: $(cat android/app/src/main/assets/app.json)"
          else
            echo "âŒ ERROR: app.json was NOT copied to assets folder!"
            exit 1
          fi

      - name: Build React with App ID
        env:
          REACT_APP_APP_ID: ${{ env.APP_ID }}
        run: |
          echo "ðŸ”¨ Building React app with REACT_APP_APP_ID=${REACT_APP_APP_ID}"
          echo "ðŸ“± This appId (${REACT_APP_APP_ID}) will be dynamically passed to GraphQL Layouts query"
          npm run build
 
      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: "temurin"
          java-version: "17"
 
      - name: Verify app.json before Android build
        run: |
          if [ ! -f app.json ]; then
            echo "âŒ app.json not found!"
            exit 1
          fi
          APP_NAME_FROM_JSON=$(node -p "require('./app.json').name || 'MobiDrag'")
          echo "âœ… App name in app.json: ${APP_NAME_FROM_JSON}"
          echo "ðŸ“± This will be used for BuildConfig.APP_NAME in Android build"

      - name: Build Android APK
        run: |
          cd android
          chmod +x ./gradlew
          ./gradlew assembleRelease
          
      - name: Fix React Native Autogenerated File
        env:
          PACKAGE_NAME: ${{ env.PACKAGE_NAME }}
        run: |
          if [ -n "${PACKAGE_NAME}" ]; then
            echo "ðŸ”§ Fixing ReactNativeApplicationEntryPoint.java with package: ${PACKAGE_NAME}"
            node scripts/fix-react-native-entry-point.js "${PACKAGE_NAME}"
          else
            echo "âš ï¸ PACKAGE_NAME not set, skipping fix"
          fi
          
      - name: Build Android APK (Final)
        run: |
          cd android
          chmod +x ./gradlew
          ./gradlew assembleRelease

      - name: Prepare APK for release
        id: prepare_apk
        env:
          APP_NAME: ${{ env.APP_NAME }}
        run: |
          APK_PATH="android/app/build/outputs/apk/release/app-release.apk"
          if [ -n "${APP_NAME}" ]; then
            # Use app name for APK filename (sanitize for filesystem)
            # Format: appname.apk (no build number, no app ID)
            SANITIZED_NAME=$(echo "${APP_NAME}" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')
            APK_NAME="${SANITIZED_NAME}.apk"
          else
            APK_NAME="app.apk"
          fi
          cp "$APK_PATH" "$APK_NAME"
          echo "apk_name=$APK_NAME" >> "$GITHUB_OUTPUT"
          echo "apk_path=$APK_NAME" >> "$GITHUB_OUTPUT"
          echo "âœ… APK prepared: $APK_NAME"

      - name: Create GitHub release with APK
        env:
          GH_TOKEN: ${{ github.token }}
          APP_NAME: ${{ env.APP_NAME }}
        run: |
          # Use app name from mutation response, fallback to "android-build" if not available
          if [ -n "${APP_NAME}" ] && [ "${APP_NAME}" != "App-${APP_ID}" ]; then
            # Use app name for release (sanitize for filesystem)
            SANITIZED_NAME=$(echo "${APP_NAME}" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9-]//g')
            TAG_NAME="${SANITIZED_NAME}-${GITHUB_RUN_ID}"
            RELEASE_NAME="${APP_NAME} - Build ${GITHUB_RUN_NUMBER}"
            RELEASE_NOTES="Automated Android build for ${APP_NAME} (APP_ID=${APP_ID})"
          else
            # Fallback to default naming
            TAG_NAME="android-build-${GITHUB_RUN_ID}"
            RELEASE_NAME="Android build ${GITHUB_RUN_NUMBER}"
            RELEASE_NOTES="Automated Android build for APP_ID=${APP_ID}"
          fi

          echo "ðŸ“¦ Creating release: ${RELEASE_NAME}"
          echo "ðŸ·ï¸  Tag: ${TAG_NAME}"

          # Create release with APK as downloadable asset
          gh release create "$TAG_NAME" \
            "${{ steps.prepare_apk.outputs.apk_name }}" \
            --title "$RELEASE_NAME" \
            --notes "$RELEASE_NOTES" \
            --latest=false || echo "âš ï¸ Release may already exist, continuing..."
          
          # Get the asset download URL for users
          ASSET_URL=$(gh release view "$TAG_NAME" --json assets -q '.assets[0].browser_download_url' 2>/dev/null || echo "")
          if [ -z "$ASSET_URL" ]; then
            # If release exists, upload the APK as an asset
            gh release upload "$TAG_NAME" "${{ steps.prepare_apk.outputs.apk_name }}" --clobber 2>/dev/null || echo "âš ï¸ Could not upload APK"
            ASSET_URL=$(gh release view "$TAG_NAME" --json assets -q '.assets[0].browser_download_url' 2>/dev/null || echo "")
          fi
          {
            echo "### Android build generated"
            if [ -n "${APP_NAME}" ] && [ "${APP_NAME}" != "App-${APP_ID}" ]; then
              echo "**App:** ${APP_NAME}"
            fi
            echo "- APK: [${{ steps.prepare_apk.outputs.apk_name }}]($ASSET_URL)"
            echo "- APP_ID: ${APP_ID}"
            echo "- Release: [${RELEASE_NAME}](https://github.com/${{ github.repository }}/releases/tag/${TAG_NAME})"
          } >> "$GITHUB_STEP_SUMMARY"
